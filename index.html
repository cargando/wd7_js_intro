<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<br />
<h1>JavaScript Intro</h1>



<!-- HTML комментарий -->
<img src="data:image/jpeg;base64,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"
		 alt="Котяра"
		 title="Котяра"
>
<script>
  // однострочный комментарий

  /*

	это
	многострочный


	комментарий
	*/

  console.log(`Привет МИР!!!`); // однострочный комментарий

  // Переменная - это "коробочка" в которую можно положить какие-то данные
  // вы должны уведомить браузер/JS о том, что хотите использовать новую переменную "коробочку"
  // для этого нужно использовать ключевое слово var - это специально зарезервированное слово
  // с помощью которого происходит объявления новой переменной, другими словами мы уведомляем браузер о том,
  // что нам необходима новая коробка-переменная, куда в дальнейшем мы будем складывать/хранить нужные нам данные/информацию

  // название переменной может начинаться с любого символа латинского алфавита (верхний или нижний регистр) а так же со знаков $ и _  (доллар и подчеркивание)
  // остальные симполы недопустимо использовать в качестве первого символа в названии ПЕРЕМЕННОЙ (коробки)
  // После первого символа в названии переменной можно уже использовать и цифры (но не наоборот)


  var user = 'Вася'; // создал коробку, в которую поместил текстовую информацию "Вася"

  console.log("Значене переменной user", user, Number.MAX_SAFE_INTEGER);

  // ТИПЫ ДАННЫХ - разный вид информации (аналогия это как состояние вещества: твердый, жидкий, газообразный и пр)
  // только в отношении информации, т.е. информация тоже может быть разнородной, может быть строкой текста, может быть числом, может быть булевым и тд

  // string - строка текста
  var user1 = 'Вася 1'; // строка текста объявляется через пару кавычек (первая кавычка - это начала текста, вторая кавычка - окончание строки текста)
  var user2 = "Вася 2"; // допустимы все 3 вида кавычек: одинарные, двойные
  var user3 = `Вася 3`; // и тильда

  // number - число
  var userAge = 500;

  // boolean - битовый или двоичный тип данных
  // false / true => (нарусском) => ложь / правда
  var userMarried = false;
  var userGotChild = true;

  // object - объект
  // коробка в которой можно хранить множество других коробок
  var user5 = {};

  // null - нулевый тип данных
  var dd = null; // null - это 1) метка, обозначающая "пустоту"; 2) это в тоже самое время
  var ff = null; // название типа данных

  // undefined - неопределенный

  var tt1 = undefined; // undefined - это 1) метка, обозначающая что у переменной нет значения с момента ее создания;
  var tt2 = undefined; // 2) это в тоже самое время название типа данных

  var tt3;

  console.log("Переменная user1 = ", user1, user2, user3);

  console.log("Переменная userAge = ", userAge);

  console.log("Переменная userMarried, userGotChild = ", userMarried, userGotChild);

  console.log("Переменная user5 = ", user5);

  console.log("Переменная dd, ff = ", dd, ff);

  console.log("Переменная tt1, tt2, tt3 = ", tt1, tt2, tt3);

  var tt4 = 'Марина';

  console.log("Переменная tt4 = ", tt4);

  // typeof - ключевое слово, оператор для определения типа данных переменной

  console.log("Тип данных переменной user1 = ", typeof user1);
  console.log("Тип данных переменной userAge = ", typeof userAge);
  console.log("Тип данных переменной userMarried = ", typeof userMarried);
  console.log("Тип данных переменной user5 = ", typeof user5);
  console.log("Тип данных переменной dd (null) = ", typeof dd);
  console.log("Тип данных переменной tt1 = ", typeof tt1);

  var booleanVal = true;
  var numberVal = 500;
  // alert("Результат: ", typeof booleanVal);

  console.log("Результат: " + typeof booleanVal);
  console.log("Результат: " + numberVal); // если есть строка, тогда все пытается преобразовать в строку

  var a = "10"; // -> преобразовал в число 10
  var b = "5";  // -> преобразовал в число 5
  var с = 2;

  console.log("Результат деления ");
  console.log(a / b);
  console.log(a / с);

  console.log(a + с); // тут приоритет операции над строковыми данными

  console.log( с / "sdfs");


  if ( "0" ) {
    console.log("IF >> проверил, результат TRUE");
  } else {
    console.log("IF >> проверил, результат FALSE");
  }


  // преобразовании в тип boolean происходит следующее
  // null -> false
  // undefined -> false
  // число 0 -> false
  // '' - пустая строка -> false
  // NaN -> FALSE
  // все остальное интерпритируется как TRUE


  console.log("Результат сложения строки и boolen = " + booleanVal);

  var k = 10;
  k = -k; // в этом месте минус является унарным опертором
  var t = k - 5; // в этом месте минус является БИНАРНЫМ опертором

  console.log("Результат k = ", t);

  var str2 = "100";

  console.log( +str2, typeof +str2) ; // плюс тоже может быть унарным оператором - в этом случае
  // происходит преобразование строки
  // к типу данных number

  console.log("Результат преобразования true = ", +true)
  console.log("Результат преобразования false = ", +false)
  console.log("Результат преобразования пустой строки = ", +'');

  var res = 4 + 5 - 3 * 3 / 2; // математические операторы

  console.log("10 процент 1 = ", 10 % 1);
  console.log("10 процент 2 = ", 10 % 2);
  console.log("10 процент 3 = ", 10 % 3);
  console.log("10 процент 5 = ", 10 % 5);
  console.log("10 процент 8 = ", 10 % 8);

  console.log("Возведение в степень 3 в степени 3 = ", 3 ** 3);

  var y = 9;
  var r = 15;

  console.log("Инкремент 9", ++y); // аналогия y = y + 1

  console.log("Декремент 15", --r); // аналогия r = r - 1

  // console.log("Возведение в степень 3 в степени 3 = ", 3 ** 3);

  var u = 10;
  console.log("Инкремент 10", u++); // аналогия u = u + 1
  console.log("Инкремент 10 (вторая фаза)", u);

  var qq = 12;

  qq = qq * 2; // = 24 // это оператор
  qq *= 2; // = 24 		// эквиваленен этому оператору

  qq /= 2;  // qq = qq / 2
  qq += 200;  // qq = qq + 200
  qq -= 15; // qq = qq - 15


  var s1 = 10, s2 = 15, s5 = 'string 111';
  /*
		var s1 = 10;
		var s2 = 15;
		var s5 = 'string 111';
	*/


  var userName1 = 'Маруська';
  console.log("userName1 = ", userName1);
  // ..... через 100500 строк кода
  var userName1 = 'Анастасия'; // эквивалент как буд-то вы просто присваиваете новое значение для уже ранее созданной переменной
  // userName1 = 'Анастасия'
  console.log("userName1 = ", userName1);

  var cc = "w";

  // ОПЕРАТОРЫ СРАВНЕНИЯ

  // == -> опарация сравнения двух переменных / объектов / строк и тд

  console.log("Результат сравнения 2 == 2", 2 == 2 );
  console.log("Результат сравнения 2 == 3", 2 == 3 );

  // === -> операция сравнения двух переменных с учетом типа данных
  console.log("Результат сравнения 2 === '2' ", 2 === '2' );

  // console.log("Результат сравнения 0 == null ", 0 == undefined ); // уточнить

  // как сравниваются строки: js сравнивает 2 строки последовательно посимвольно

  console.log("Результат сравнения 'abc' == 'abc'", 'abc' == 'abc' );
  console.log("Результат сравнения 'abc' == 'abd'", 'abc' == 'abd' );

  // > -> сравнение БОЛЬШЕ
  // < -> сравнение МЕНЬШЕ
  // >= -> БОЛЬШЕ либо РАВНО
  // <= -> МЕНЬШЕ либо РАВНО

  // тоже самое с сравнение с учетом типа данных
  // >== БОЛЬШЕ либо РАВНО с учетом типа данных
  // <== МЕНЬШЕ либо РАВНО с учетом типа данных
  // === -> РАВНО с учетом типа данных

  console.log("Результат сравнения 'abc' >= 'abd'", 'abc' >= 'abd' );
  console.log("Результат сравнения 'abc' <= 'abd'", 'abc' <= 'abd' );


  console.log("Результат сравнения null == undefined", null == undefined );
  console.log("Результат сравнения null === undefined", null === undefined );


  if (5 < 10) {
    console.log("Результат сравнения 5 < 10 = TRUE");
  } else {
    console.log("Результат сравнения 5 > 10 = FALSE");
  }
  // alert("Какое-то сообщения для юзера"); // вывести текстовое сообщение для пользователя

  // var res1 = prompt("Yo!!! введите что-нибудь: "); // вывести текстовое сообщение для пользователя
  // console.log("Юзер ввел в окошко Prompt следующее значение:", res1);

  // var res2 = confirm("Yo!!! Хотите отформатировать диск С ???? "); // вывести текстовое сообщение для пользователя
  //console.log("Юзер согласен/не согласен форматнуть диск:", res2);

  // УСЛОВНЫЙ ОПЕРАТОР IF
  // предназначен для сравнения чего-то с чем-то (например двух переменных)
  // или выяснения является ли какая-то переменная истинной или ложью
  // и на основе этого выполнить блок кода

  if (5 < 10) // в круглых скобка вычисляется выражение - true или false
  { // далее исполняется этот блок кода если в if было TRUE
    console.log("Результат сравнения 5 < 10 = TRUE");
  }
  else // эта половина необязательна
  { // ЛИБО исполняется этот блок кода если в if было FALSE
    console.log("Результат сравнения 5 > 10 = FALSE");
  }

  if (5 < 10) // в круглых скобка вычисляется выражение - true или false
  { // далее исполняется этот блок кода если в if было TRUE
    console.log("Результат сравнения 5 < 10 = TRUE");
  }

  // вариации с комбинированием

  if (5 < 10) // в круглых скобка вычисляется выражение - true или false
  { // далее исполняется этот блок кода если в if было TRUE
    console.log("Результат сравнения 5 < 10 = TRUE");
    console.log("Результат сравнения 5 < 10 = TRUE");
    console.log("Результат сравнения 5 < 10 = TRUE");
    console.log("Результат сравнения 5 < 10 = TRUE");
    console.log("Результат сравнения 5 < 10 = TRUE");

  }
  else if (1 > 0)// эта половина необязательна
  { // ЛИБО исполняется этот блок кода если в if было FALSE
    console.log("Результат сравнения 5 > 10 = FALSE");
  } else {
    // ....
  }

  // тернарный оператор
  // это аналогия конструкции IF....ELSE...
  // три области: первая область до знака вопроса - там указывается условия для вычисления
  // вторая область между знаком вопроса и двоеточием - соответствует IF вернул TRUE
  // третья область после двоеточия - соответствует IF вернул FALSE, т.е. соответствет ELSE
  var tort = 'Наполеон'
  var resTort = (tort == 'Мильфой' ? 'нравится' : ' не нравится');

  console.log("Я сегодня съем тортик, который мне ", tort == 'Мильфой' ? 'нравится' : ' не нравится')
  console.log("Я сегодня съем тортик, который мне ", resTort)


  var guest = 'Семеныч';
  var guestEat = 'Угостить ';

  switch (guest) {

    case 'Vasya': guestEat += 'Kotleta'; break;
    case 'Masha': guestEat += 'Napoleon';  break;
    case 'Dash': guestEat += 'Milfoi';  break;
    case 'Grisha': guestEat += 'Grechka'; break;
    default: guestEat += ' просто водой';

  }

  console.log("Switch Case -> ", guestEat)


  // внутри Switch Case можно писать большое количество операций
  var guest1 = 'Vasya';
  var guestEat1 = 'Угостить ';

  switch (guest1) {

    case 'Vasya':
      guestEat1 += 'Kotleta';
      guestEat1 += ' и потом еще залакировать шоколадкой';
      console.log('Пришел мой любимый гость');
      break;
    case 'Masha': guestEat1 += 'Napoleon';  break;
    case 'Dash': guestEat1 += 'Milfoi';  break;
    case 'Grisha': guestEat1 += 'Grechka'; break;
    default: guestEat1 += ' просто водой';

  }

  console.log("Switch Case -> ", guestEat1);


  // ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
  // || => OR - логическая операция ИЛИ => если перейти в математику, то это СЛОЖЕНИЕ
  // && => AND  - логическая операция И => если перейти в математику, то это УМНОЖЕНИЕ
  // ! => NOT  - логическая операция НЕ (исключение)

  var tq1 = 100;
  var tq2 = 40;

  var chekRes = 50;

  // AND
  if (chekRes > tq2 && chekRes > tq1 ) {
    console.log("Да, chekRes больше чем tq1 и tq2 ");
  } else {
    console.log("НЕТ, chekRes одновременно НЕ больше чем tq1 и tq2 ");
  }

  // OR
  if (chekRes > tq2 || chekRes > tq1 ) { // кол-во логических операция может быть многократно больше чем 2, указанные в этом примере
    // например if (chekRes > tq2 || chekRes > tq1 || chekRes > 300 && chekRes != 0  )
    console.log("Да, chekRes больше чем tq1 или больше чем tq2 ");
  } else {
    console.log("НЕТ, chekRes одновременно НЕ больше чем tq1 и tq2 ");
  }

  // NOT
  var f1 = 100;
  var f2 = 101;

  if (f1 == f2 ) {
    console.log("Да, f1 РАВНО f2 ");
  } else {
    console.log("НЕТ, f1 НЕ РАВНО f2 ");
  }

  if (f1 != f2 ) {
    console.log("НЕТ, f1 НЕ РАВНО f2 ");
  } else {
    console.log("Да, f1 РАВНО f2 ");
  }

  // МАССИВЫ
  // чтобы объявить массив нужно использовать последовательность квадратных скобок

  var ms1 = []; // мы создали переменную, в которой хранится пустой массив (нет вагончиков-элементов)
  var ms2 = [1, 2, 600]; // создал массив, из трех элементов (вагончиков): элементы имеют тип число (number)

  console.log("Массив ms = ", ms2); // это просто вывод в консоль массива ЦЕЛИКОМ

  console.log("Длинная массив ms2 = ", ms2.length); // таким образом мы узнаем длинную массива

  console.log("Элемент массива ms2 с индексом 2 (3й вагончик) = ", ms2[ 2 ] ); // таким образом мы узнаем длинную массива

  var spisokGostei = ['Маша', 'Даша', 'Глага', 'Витя', 'Семеныч']; // массив строк

  var ms3 = [400, 'Маша', true, null, "Проект", "Mras", 100500]; // массив разных элементов (разный тип данных)

  var ms4 = ['Маша', 125, true, spisokGostei]; // массив разных элементов (разный тип данных)

  console.log("Пример вложенного массива ", ms4);

  console.log("ms3[0]", ms3[0]);
  console.log("ms3[1]", ms3[1]);
  console.log("ms3[2]", ms3[2]);
  console.log("ms3[3]", ms3[3]);
  console.log("ms3[4]", ms3[4]);
  console.log("ms3[5]", ms3[5]);
  console.log("ms3[6]", ms3[6]);

  console.log("Тоже самое только через цикл WHILE");
  // while ( /* вспомогательное действие - условие срабатывания тела цикла */ ) {
  // ТЕЛО ЦИКЛА = набор действий, который нужно многократно повторить
  // если внутри вспомогательного действия = TRUE, тогда выполняется тело цикла
  // если внутри вспомогательного действия = FALSE, тогда НЕ выполняется тело цикла
  // }

  var cnt = 0; // вспомогательная переменная для обхода массива

  // цикл WHILE - сначала проверить условия прекращения/выполнения цикла, а потом
  // делай тело цикла
  while ( cnt  < ms3.length ) { // ms3.length => 7

    console.log(
      "ms3[",
      cnt,
      "]",
      ms3[ cnt ] // ms3[ 0 ],  ms3[ 1 ],  ms3[ 2 ], и тд
    );

    cnt++;
    // ++cnt;
    // cnt = cnt + 1;
  }
  ////

  console.log("Значение счетчика после завершения цикла:", cnt);

  var i = 0;

  while ( i  < ms4.length ) { // ms3.length => 7

    var currentElement = ms4[ i ];

    if (Array.isArray( currentElement )) { // Array.isArray - узнает является ли элемент массива ms4[ i ] - вложенным подмассивом
      var j = 0;
      // while ( j  < ms4[ i ].length ) {

      while ( j  < currentElement.length ) {
        console.log("ms4[", i, "]","[", j, "]", ms4[ i ][ j ]);
        j++;
      }
    } else {
      console.log("ms4[", i, "]", ms4[ i ]);
    }


    i++;
  }

  // можно сделать цикл WHILE без вспомогательного действия
  i = 0;
  while (1) {
    if (i  < ms4.length ) {
      break; // принудительно прекратить исполнение тела цикла, начиная с этого места
    }
    if ( i == 1) {
      i++;
      continue; // переход на следующую итерацию цикла, т.е. наверх к while (......)
    }
    console.log("ms4[", i, "]", ms4[ i ]);
    i++;
  }



  // новый цикл DO .... WHILE = сначала делай тело цикла, потом проверяй условие прекращения
  i = 0;
  do {
    console.log("ms4[", i, "]", ms4[ i ]);
    i++;
  } while (i  < ms4.length);


  // ЦИКЛ FOR, в круглых скобках находятся три области
  //for (
  /* 1я - начальное условие или действия с инициализацией */
  //	; // точка с запятой - разделитель областей внутри for
  /* 2я - условие прекращения работы цикла */
  //  ; // точка с запятой - разделитель областей внутри for
  /* 3я - операции с инкрементом или операция в конце тела цикла */
  // ) { ТЕЛО ЦИКЛА }

  console.log("Тоже самое с помощью цикла FOR ");

  for (var i = 0; i  < ms4.length; i++) {
    console.log("ms4[", i, "]", ms4[ i ]);
  }

  // любую область из круглых скобок можно вынести в другое место
  var i = 0;
  for ( ; i  < ms4.length;) {
    console.log("ms4[", i, "]", ms4[ i ]);
    i++;
  }



  // пример с домашним заданием
  var meal = 'Курица жаренная';
  var water = 'Просто вода';

  var shit = 'что-то не съедобное';
  var oil = 'нефть';

  function printUser(localMeal, localWater, gender = "male") { // ждет на вход (съесть) еду и воду

    return 'User ест такой набор:' + localMeal + ", " + localWater + ", " + gender;
	}

  printUser(meal, water);
  printUser(meal, oil);
  printUser(shit, oil, "female");




  ///////// ОБЪЕКТЫ ////////////


  var ob1 = {
    fio: "Иван Иваныч Иванов",
		age: 30,
		phone: {
      code: '495',
			number: '5551212',
		},
		printUserName() {
      console.log(this.fio);
      console.log("сравнение с window", this === window);
		}
	};

  var ob2 = ob1 // копирование по ссылке, т.е. мы копируем ссылку на адрес в памяти, по которому уже находятся реальные данные (Иваныч, 30)

	// как по нормальному скопировать данные, чтобы они были полноценным дубликатом

	var ob3 = /* второе действие */ JSON.parse(  /*  это первое действие */ JSON.stringify(ob1)    )
	// первое действие - из объекты JS сделать просто строку текста, в формате JSON
	// второе действие - из строки текста JSON сделать в памяти интерпритатора еще один объект

	var ob4 = Object.assign({}, ob1); // создает дубликат данных первого уровня, данные второго уровня, если это объект - будут по ссылке.

	ob4.phone.code = '999';

	var ob5 = { ...ob1, phone: { ...ob1.phone } };

  ob1.address = 'Г.Москва,ул.Партизанская 10'; // создать новое поле в объекте, в любой момент времени
  ob1['email'] = 'my@mail.ru'; // создать новое поле в объекте

	// если нужно удалить поле из объекта с потерей данных
	delete ob1.phone;

	var b = 10;
	delete b;

	var ms = [1,2,3,4,5]; // массив - это тоже тип данных объект (Object), у которого есть специальный механизм,
	// позволяющий быстрее работать с упорядоченными целочисленными ключами (индекс массива - это ключ или поле/свойство объекта)
	delete ms[2];
	console.log("ms", ms);

  ms.length = 100;

  var c = `Привет дорогой ${ ob1.fio ? 'это Иваныч' : 'нет имени' }${ob1.address}`;
  console.log("c = ", c);



  function printUserName() { // функция в JS - это тоже тип данных объект (Object)

    console.log("printUserName this:", this === window); // проверяем что при исполнении этой функции
		// ключевое слово this внутри нее на момент исполнения будет равно глобальному объекту window (самая большая "матрешка")
  }

  printUserName(); // выполняем функцию, как бы от лица (в контексте) объекта window, т.е. как метод window.printUserName()

	console.log("ob1.printUserName = "); // вывод в консоль тоже можно записать как часть объекта window -> window.console.log("ob1.printUserName = ")
	ob1.printUserName();

	// setTimeout(window.ob1.printUserName, 500);

	// ВАЖНО!
	// ВСЕ переменные и функции, которые объявлены на первом уровне вложенности в объекте window
	// можно использовать (или вызывать/исполнять) без префикса window.
	// причем работать будут оба варианта: и с префиксом, и без


	//////////////////////// ФУНКЦИЯ-КОНСТРУКТОР
	// функцией-конструктором может быть любая функция, название которой начинается с большой буквы латинского алфавита
	// функция-конструктор - это шаблон, на основе которого можно создать объект-экземпляр из функции-конструктора
	// вспоминаем аналогию, что функция-конструктор - это техническая документация, на основе которой можно что-то сделать
	// объект-экземпляр - это, условно "реальная вещь", которую создали по чертежам или технической документации (т.е. из функции-конструктора)

	function SuperUser(localName, localAge, localPhone = 'no phone') {

	  this.name = localName; // user6.name....
	  this.age = localAge; // user6.age....
	  this.phone = localPhone;

	  this.prinUserInfo = function () {
	    return this.name + ", " + this.age;
		}
		console.log("wind", window.name);
  }

  // создаем экземпляр-объекта на основе функции-конструктора SuperUser
  // результат будет помещен в переменную user6
  var user6 = new SuperUser('Семен Семеныч', 30, '555-12-12');
  // аналогия { }.SuperUser('Семен Семеныч', 30, '555-12-12')
	// результат будет условно таким user6 = { name:'...', age: '...', phone: '...' }


	//////// ВАЖНО!!!
	// механика создание объекта через оператор NEW:
	// оператор NEW создает путой объект { } т.е. в этом объекте нет ни одного поля или метода
	// вторым шагом оператор NEW берет функцию-конструктор (функция которая указана справа от оператора new)
	// и меняет ей контекст исполнения, т.е. как бы прикрепляет функцию-конструктор к только что созданному объекту
	// и далее выполняет эту функцию-конструктор
	// если внутри функции-конструктора есть операции с ключевым словом this, тогда это значит что this указывает на
	// тот самый объект, который только что создал NEW и от лица, которого выполняется функция-конструктор
	// следовательно когда мы внутри функции-конструктора пишем this.name = '...' - это значит что внутри толко что созданного объекта
	// появится поле "name" с каким-то значением, аналогия { name: "...." }

	console.log(ob1);
	console.log(user6, window.name);



	//////////////////////// КЛАССЫ - это так называемый "синтаксический сахар", по факту (под капотом)
	// это все теже функции конструкторы (шаблоны, т.е. "техническая документация") на основе которых
	// создаются экземпляры объектов, как бы из техдокументации создается реальный самолетик на "заводе"
	// а "завод" - это собственно и есть оператор NEW, который и устраивает весь процесс создания объекта
	//  на основе того самого шаблона т.е. класса или функции конструктора
	class SuperMegaMan {

	  constructor(name, age, phone) {
	    this.fio = name;
	    this.age = age;
	    this.phone = phone;
    }

    printUserInfo() {
	    return this.fio + ", " + this.age;
		}
	}

	// создаем экземпляр-объекта на основе шаблона-класса SuperMegaMan
	// результат будет помещен в переменную user7
	var user7 = new SuperMegaMan("Петрович", 40, "444-1212");
  // аналогия { }.SuperMegaMan("Петрович", 40, "444-1212")
  // результат будет условно таким user7 = { fio:'...', age: '...', phone: '...' }

  console.log(user7);


  var ob10 = {
    cinema: 'Karo Films',
		movie: 'Matrix 10',

		printCinemaInfo() {
      console.log("Информация по кинотеатру: ", this.cinema, this.movie);
		}
	}

	var ob11 = {
    restoran: "Sushi wohk",
		dish: 'Kalifornia',

    printRestoranInfo(time, secondTime) {
      console.log("Информация по ресторану: ", this.restoran, this.dish, " at ", time, secondTime);
    }
	}
	console.log("Пример CALL:")
  ob11.printRestoranInfo("10:00");
	ob11.printRestoranInfo.call(ob10, "11:00", "18:00");
	ob11.printRestoranInfo.apply(ob10, ["11:00", "17:00"]);

	(ob11.printRestoranInfo.bind(ob10, "15:00", "16:00"))(); // немедленно исполняемая функция

  // funtionCallMeLater();
  // Косвенный вызов метода/функции через call, apply, bind

	console.log("OB = ", {} == {}, {} === {});
	if ({} == {}) {
	  console.log("OB == true")
	} else {
    console.log("OB == false")
	}

	function sst(firstName, secondNAme) {


	  console.log("sst.name = ", sst.name, sst.extra);

	  var result = {
      first: firstName,
			second: secondNAme,
      fullName: firstName + " " + secondNAme,

			printName: function () {
				return this.first;
      },

      printUser() {
        return this.first;
			}
		}

		return result;

	  console.log("Hello")

  }
  sst.extra = 555;


	/// Object.key.values.entries
	// функции обертки над приметивами

	var str2 = "Какой-то текст на русском языке";

	console.log("Длинна строки", str2.length );
	console.log("трансформированная строка", str2.toLocaleUpperCase() );

	// String();
  // String.toLocaleUpperCase();
  // String.length;
	//
	//
  // String(str2).length;
  // String(str2).toLocaleUpperCase();

  // Object() --> { }

	var rrKeys = Object.keys(ob1);
	var rrValues = Object.values(ob1);
	var rrEntries = Object.entries(ob1);
	console.log("Ключи объекта ob1", rrKeys, rrValues);
	console.log("Entries объекта ob1", rrEntries);

  console.log(String(ob1).toString());
  var str3 = "   sdfsdfsdf       ";
  console.log(str3.length, str3.trim().length );

  var str4 = "Какой-то.текст,с,очень.интересными,буквами";

  var resStr4 = str4.split(",");
  console.log("Количество запятых = ", resStr4.length - 1);
  console.log("Количество точек = ", str4.split(".").length - 1);

  var strS = 'Марина съела утром __RPLC__ вкусных булочек.';

  console.log(strS.replace("__RPLC__", "15"), str4.charAt(10));


  //// Встроенные методы массивов

	var SWEET_CONSTANT = "Сладкий";

	var ms10 = [
		{
		  name: "Банан",
			taste: SWEET_CONSTANT,
			size: "M",
		},
		{
		  name: "Апельски",
			taste: "Кисло-Сладкий",
			size: "S",
		},
		{
		  name: "Лемон",
			taste: "Кислый",
			size: "S",
		},
		{
		  name: "Тыква",
			taste: "терпкая",
			size: "XL",
		},
		{
		  name: "Виноград",
			taste: SWEET_CONSTANT,
			size: "xs",
		},
	];

	function printVegetables(item) {

		console.log(`Продукт: ${ item.name} имеет вкус '${ item.taste }', имеет размер '${ item.size }'`);
	}

	function printVegetablesUnkown(item) {
		if (typeof item === "object") {
		  var resStr = [];
		  Object
				.values(item)
				.forEach( function(localItem, index, originalMS) {
          resStr.push(localItem);
				});
      console.log("Продукт: ", resStr.join(" "));
		} else {
      console.log("Продукт (примитивный): ", item);
		}

	}



  ms10.forEach(printVegetables);
  console.log("-- -------");
  ms10.forEach(printVegetablesUnkown);


  function printVegetablesMap(item) {
    return `Продукт: ${ item.name} имеет вкус '${ item.taste }', имеет размер '${ item.size }'`;
  }

  console.log("-- ------- MAP ");
  var mapResult = ms10.map(printVegetablesMap)
  console.log(mapResult);

  var newMS = ["Василек", "Ромашка", "Пион"];
  console.log("Резульат объединения двух массивов", ms10.concat(newMS))

	function filterSweetVegs(item) {
    return item.taste && (item.taste.toLocaleLowerCase() === SWEET_CONSTANT.toLocaleLowerCase());

    // false || false || true || 5+6

	}

	var onlySweetVeg = ms10.filter(filterSweetVegs).map(printVegetablesMap);
  console.log("Только сладкие объекты", onlySweetVeg);

  ms11 = [55, 33, 44, 99];
  console.log(ms11.includes(99)); // узнает есть такой элемент
  console.log(ms11.indexOf(990)); // выдает индекс элемента, если есть


	ms12 = [44, 2, 6, 89, 13, 67, 44, 23];

	function sortMyArray(a, b) {
	  if (a < b) return -1;
	  else if (a > b) return 1;
	  else return 0;
	}

	function sortVerggy(a, b) {

    var a1 = a.name.toLocaleLowerCase()
    var b1 = b.name.toLocaleLowerCase()

	  if (a1 < b1) return -1;
    else if (a1 > b1) return 1;
    else return 0;
	}

	// console.log(ms12.slice().sort())
	// console.log(ms12.sort(sortMyArray))

	console.log(ms10.sort(sortVerggy))

  // var delResult = ms12.splice(5, 2); // удалить 2 элемента
	// console.log("Удалили ", delResult, ", результат: ", ms12)

  var addResult = ms12.splice(1, 2, "Золушку", "Тыква"); // хочу добавить 3 элемента
  console.log("Добавили ", addResult, ", результат: ", ms12)

  ms15 = [44, 2, 6, 89, 13, 67, 44, 23];

  ms15.reduce(function(acc, item, index) {

    console.log("Шаг ", index, "Результат сложения: ", acc );
		return acc + item;
	});

  // Symbol

	var mySymbol = Symbol();
  console.log("Объект символ ", mySymbol );

	var mySymbol1 = Symbol("Hello");
	var mySymbol2 = Symbol("Hello");
  console.log("Объект символ ", mySymbol1 === mySymbol2);

  var user500 = {
    name: "sdfsdf",
		age: 40,
		[mySymbol1]: "Поле на основе символа"
	}

	console.log("Поле >> ", user500[mySymbol2]);


  // гетеры и сетеры = getter & setter

	var user12 = {
	  fName: "",
	  lName: "",
		age: 30,

		printUserName() {
	    return this.fName + " " + this.lName;
		},

		checkUserEmail() {
			;
		},

		get fullName() {
	    return this.fName + " " + this.lName;
		},

		set fullName(val) {
	    var res = val.split(" ");
	    if (res[0]) {
	      this.fName = res[0];
			}
	    if (res[1]) {
	      this.lName = res[1];
			}
		}

	}

	console.log("user12 через метод =", user12.printUserName() )

  user12.fullName = "Иван Семеныч";

	console.log("user12 через гетер =", user12.fullName )

	Object.defineProperty(user12, "email", {
	  value: 'asd@mail.ru',
	  writable: false,
		enumerable: true,
		configurable: true,
	});

	console.log(Object.keys(user12));

	function SuperUser(fname, lname) {
	  this.fName = fname;
	  this.lName = lname;

	}

	var user13 = new SuperUser("Семен", "Семеныч");
	var user14 = new SuperUser("Иван", "Иваны");

	console.log("Объект", user13, user14);
	console.log("Объект.__proto__", user13.__proto__)
	console.log("Объект.__proto__.constructor", user13.__proto__.constructor);
	// console.log("Функция конструктор", SuperUser);

	var Clara = { name: "Clara"};
	var Alex = { name: "Alex" };

  Clara.__proto__ = Alex; // отличное от базового core Object

  console.log("Объект", Clara, Clara.name)

	// Object() // обладает встроенным свойством prototype
	// String()
	// Number()

  console.log("Object.prototype = ", Object.prototype) // получаем ссылку на корневой объект core Object
  console.log("Object.prototype = ", Object.prototype.__proto__) // пытаемся у core Object посмотреть родителя/предка = null
  Object.prototype; // это просто свойство prototype, которое автоматом создается у всех функций в JS


	function Country(name, capital, population, square) {
	  this.name = name
	  this.population = population
	  this.square = square
	  this.capital = capital
	}

	Country.prototype["printInfo"] = function () {
    return `Информация: ${ this.name }, ${this.capital}, ${this.population}, ${this.square}`;
    // return "Информация: " + this.name + " " + this.capital + " " + this.population + " " + this.square;
  }



	var Russia = new Country("Россия", "Москва", 145000000, 100500);
	var France = new Country("France", "Paris", 80000000, 10500);
	var Germany = new Country("Germany", "Berlin", 7000000, 9500);

	console.log(Russia.printInfo());
	console.log(France.printInfo());
	console.log(Germany.printInfo());


	console.log("Прототип Clara", Object.getPrototypeOf(Clara));
	console.log("является ли  Alex родителем Clara", Alex.isPrototypeOf(Clara));

	// есть строка текста, нужно взять и сделать функцию, которая дублирует искомую строку N раз,
	// при этом функция должна быть встроенным методом для всех строк.

	var str55 = "Какой-то интересный текст!";
	var str80 = "Other text";


	String.prototype.duplicate = function (val) {
	  // var res = this; // в этом примере this указывает на контекст исполнения, т.е. на строку текста - переменную str55
	  var res = "";

		while(val--) {
      res += this;
      // res = res + this;
		}
		return res;
  }

  console.log("str55.__proto__", str55.__proto__);
  console.log("Результат", str55.duplicate(3));
  console.log("Результат", str80.duplicate(2));

  console.log("Результат", "Супер строка".duplicate(2));

  // Какой-то интересный текст!Какой-то интересный текст!Какой-то интересный текст!

	// дан массив, подсчитать кол-во положительных или отрицательных
	Array.prototype.countSign = function (tp) {
		var cnt = 0;
	  this.forEach(function (item) {
	    if (tp === "-" && item < 0) {
        cnt ++;
			} else {
        cnt ++;
			}
		});

	  return cnt;
  }

	// Array.prototype.countSign = function (ms, tp) {
	// 	var cnt = 0;
  //   ms.forEach(function (item) {
	//     if (tp === "-" && item < 0) {
  //       cnt ++;
	// 		} else {
  //       cnt ++;
	// 		}
	// 	});
	//
	//   return cnt;
  // }

  var ms10 = [-5, -6, -7, 4, -9, 0, 54, -3, 3];
  console.log("Результат с массивом ", [-5, -6, -7, 4, -9, 0, 54, -3, 3, 8, -12, -15].countSign("-"));
  console.log("Результат с массивом ", ms10.countSign("-"));



</script>
</body>
</html>
